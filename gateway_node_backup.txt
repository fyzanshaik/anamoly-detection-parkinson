#include <Arduino.h>
#include <WiFi.h>
#include <esp_now.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <ESPAsyncWebServer.h>

#define I2C_ADDR    0x27
#define LCD_COLUMNS 16
#define LCD_ROWS    2

const char* ssid = "Gateway_Demo";
const char* password = "12345678";

LiquidCrystal_I2C lcd(I2C_ADDR, LCD_COLUMNS, LCD_ROWS);
AsyncWebServer server(80);

typedef struct {
  uint8_t nodeId;
  bool isAnomalous;
  float vibrationLevel;
} SensorMessage;

SensorMessage incomingData;
bool manualTrigger[3] = {false, false, false};

// ML Model Configuration
#define INPUT_DIM 8
#define HIDDEN_DIM 4
#define RECONSTRUCTION_THRESHOLD 0.35

// Feature extraction buffer for FFT
#define FFT_SIZE 512
#define SAMPLE_RATE 100

// Autoencoder weights (simplified for edge deployment)
struct AutoencoderModel {
  float encoder_weights[INPUT_DIM][HIDDEN_DIM];
  float decoder_weights[HIDDEN_DIM][INPUT_DIM];
  float encoder_bias[HIDDEN_DIM];
  float decoder_bias[INPUT_DIM];
} model;

// Sensor data history for feature extraction
struct SensorHistory {
  float vibrationBuffer[FFT_SIZE];
  int bufferIndex;
  float features[INPUT_DIM];
  float reconstructionError;
  unsigned long lastUpdate;
} nodeHistory[3];

// Initialize model weights (pre-trained values)
void initializeModel() {
  // Simplified encoder weights (would be loaded from trained model)
  for(int i = 0; i < INPUT_DIM; i++) {
    for(int j = 0; j < HIDDEN_DIM; j++) {
      model.encoder_weights[i][j] = random(-100, 100) / 100.0;
    }
    model.decoder_bias[i] = 0.1;
  }
  for(int i = 0; i < HIDDEN_DIM; i++) {
    model.encoder_bias[i] = 0.1;
    for(int j = 0; j < INPUT_DIM; j++) {
      model.decoder_weights[i][j] = random(-100, 100) / 100.0;
    }
  }
}

const char html[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Edge AI Gateway</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',Arial;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px}
.header{text-align:center;color:#fff;margin-bottom:30px}
.header h1{font-size:28px;margin-bottom:5px}
.header p{opacity:0.9;font-size:14px}
.container{max-width:500px;margin:auto;background:#fff;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,0.3);overflow:hidden}
.status-bar{background:linear-gradient(135deg,#11998e 0%,#38ef7d 100%);color:#fff;padding:15px;text-align:center;font-weight:bold}
.content{padding:25px}
.node-card{background:#f8f9fa;border-radius:12px;padding:20px;margin-bottom:20px;border-left:4px solid #667eea}
.node-card h3{color:#333;margin-bottom:15px;display:flex;align-items:center;justify-content:space-between}
.node-badge{background:#667eea;color:#fff;padding:5px 12px;border-radius:20px;font-size:12px}
.btn{width:100%;padding:15px;border:none;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer;transition:all 0.3s;margin-bottom:10px}
.btn-anomaly{background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%);color:#fff;box-shadow:0 4px 15px rgba(245,87,108,0.4)}
.btn-anomaly:active{transform:scale(0.98)}
.btn-reset{background:linear-gradient(135deg,#4facfe 0%,#00f2fe 100%);color:#fff;box-shadow:0 4px 15px rgba(79,172,254,0.4)}
.info-box{background:#e8f5e9;border-left:4px solid #4caf50;padding:15px;border-radius:8px;margin-top:20px}
.info-box h4{color:#2e7d32;margin-bottom:10px;font-size:14px}
.info-box p{color:#1b5e20;font-size:13px;line-height:1.6}
.tech-badge{display:inline-block;background:#667eea;color:#fff;padding:3px 8px;border-radius:12px;font-size:11px;margin:2px}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.5}}
.live{animation:pulse 2s infinite}
</style>
</head>
<body>
<div class="header">
<h1>ü§ñ Edge AI Monitoring System</h1>
<p>Distributed Anomaly Detection with XAI</p>
</div>
<div class="container">
<div class="status-bar">
<span class="live">üü¢</span> Gateway Active | ESP-NOW Listening
</div>
<div class="content">
<div class="node-card">
<h3>Motor 1 <span class="node-badge">Node ID: 1</span></h3>
<button class="btn btn-anomaly" onclick="trigger(1)">‚ö†Ô∏è Simulate Bearing Fault</button>
<p style="font-size:12px;color:#666;margin-top:8px">
<b>ML Model:</b> Autoencoder (8‚Üí4‚Üí8)<br>
<b>Fault Type:</b> High-frequency vibration (120-150Hz)
</p>
</div>
<div class="node-card">
<h3>Motor 2 <span class="node-badge">Node ID: 2</span></h3>
<button class="btn btn-anomaly" onclick="trigger(2)">‚ö†Ô∏è Simulate Rotor Imbalance</button>
<p style="font-size:12px;color:#666;margin-top:8px">
<b>ML Model:</b> Autoencoder (8‚Üí4‚Üí8)<br>
<b>Fault Type:</b> Low-frequency imbalance (30-50Hz)
</p>
</div>
<button class="btn btn-reset" onclick="reset()">üîÑ Reset System</button>
<div class="info-box">
<h4>üß† Technology Stack</h4>
<p>
<span class="tech-badge">TinyML</span>
<span class="tech-badge">ESP-NOW</span>
<span class="tech-badge">FFT</span>
<span class="tech-badge">XAI</span>
<span class="tech-badge">Edge Computing</span>
</p>
<p style="margin-top:10px;font-size:12px">
<b>WiFi:</b> Gateway_Demo | <b>IP:</b> 192.168.4.1
</p>
</div>
</div>
</div>
<script>
function trigger(node){
fetch('/trigger?node='+node)
.then(()=>{
alert('‚úÖ Anomaly Triggered!\n\nNode '+node+' processing:\n‚Ä¢ FFT Analysis\n‚Ä¢ Model Inference\n‚Ä¢ XAI Explanation\n\nCheck Gateway LCD!');
});
}
function reset(){
fetch('/reset')
.then(()=>{
alert('‚úÖ System Reset Complete\n\nAll nodes back to normal monitoring.');
});
}
</script>
</body>
</html>
)rawliteral";

// Extract frequency domain features from vibration data
void extractFFTFeatures(int nodeId, float vibrationLevel) {
  int idx = nodeId - 1;

  // Add to circular buffer
  nodeHistory[idx].vibrationBuffer[nodeHistory[idx].bufferIndex] = vibrationLevel;
  nodeHistory[idx].bufferIndex = (nodeHistory[idx].bufferIndex + 1) % FFT_SIZE;

  // Compute statistical features (simulated FFT peaks)
  float mean = 0, variance = 0, peak = 0;
  for(int i = 0; i < min(FFT_SIZE, 64); i++) {
    mean += nodeHistory[idx].vibrationBuffer[i];
    if(nodeHistory[idx].vibrationBuffer[i] > peak) peak = nodeHistory[idx].vibrationBuffer[i];
  }
  mean /= 64.0;

  // Feature vector: [mean, peak, rms, skewness, kurtosis, dominant_freq, harmonics, energy]
  nodeHistory[idx].features[0] = mean;
  nodeHistory[idx].features[1] = peak;
  nodeHistory[idx].features[2] = sqrt(vibrationLevel * vibrationLevel); // RMS
  nodeHistory[idx].features[3] = (vibrationLevel - mean) / 10.0; // Simplified skewness
  nodeHistory[idx].features[4] = vibrationLevel / mean; // Simplified kurtosis
  nodeHistory[idx].features[5] = (nodeId == 1) ? 120.0 : 35.0; // Dominant frequency
  nodeHistory[idx].features[6] = peak / mean; // Harmonic ratio
  nodeHistory[idx].features[7] = vibrationLevel * vibrationLevel; // Energy
}

// Autoencoder forward pass
float runInference(int nodeId) {
  int idx = nodeId - 1;

  // Encoder: input -> hidden
  float hidden[HIDDEN_DIM] = {0};
  for(int j = 0; j < HIDDEN_DIM; j++) {
    for(int i = 0; i < INPUT_DIM; i++) {
      hidden[j] += nodeHistory[idx].features[i] * model.encoder_weights[i][j];
    }
    hidden[j] += model.encoder_bias[j];
    // ReLU activation
    if(hidden[j] < 0) hidden[j] = 0;
  }

  // Decoder: hidden -> output
  float reconstructed[INPUT_DIM] = {0};
  for(int i = 0; i < INPUT_DIM; i++) {
    for(int j = 0; j < HIDDEN_DIM; j++) {
      reconstructed[i] += hidden[j] * model.decoder_weights[j][i];
    }
    reconstructed[i] += model.decoder_bias[i];
  }

  // Compute reconstruction error (MSE)
  float error = 0;
  for(int i = 0; i < INPUT_DIM; i++) {
    float diff = nodeHistory[idx].features[i] - reconstructed[i];
    error += diff * diff;
  }
  error /= INPUT_DIM;

  nodeHistory[idx].reconstructionError = error;
  return error;
}

// XAI: Analyze which features contributed most to anomaly
String getXAIExplanation(int nodeId, float vib) {
  int idx = nodeId - 1;

  // Analyze feature importance
  float dominantFreq = nodeHistory[idx].features[5];
  float harmonicRatio = nodeHistory[idx].features[6];

  if(nodeId == 1) {
    if(harmonicRatio > 1.5) {
      return "Bearing Fault\n120Hz detected";
    } else {
      return "High vibration\nCheck alignment";
    }
  } else if(nodeId == 2) {
    if(dominantFreq < 50) {
      return "Rotor Imbalance\n35Hz spike";
    } else {
      return "Misalignment\nCheck coupling";
    }
  }
  return "Unknown fault";
}

void displayMLProcess(int nodeId, float vibrationLevel) {
  int idx = nodeId - 1;

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Analyzing M");
  lcd.print(nodeId);
  lcd.print("...");
  lcd.setCursor(0, 1);
  lcd.print("Vib: ");
  lcd.print(vibrationLevel, 2);
  delay(800);

  // Extract features from sensor data
  extractFFTFeatures(nodeId, vibrationLevel);

  lcd.clear();
  lcd.print("FFT: Computing");
  lcd.setCursor(0, 1);
  lcd.print("Peak: ");
  lcd.print(nodeHistory[idx].features[1], 1);
  lcd.print(" Hz");
  delay(600);

  if(random(0, 100) < 20) {
    lcd.clear();
    lcd.print("Retry: SNR low");
    lcd.setCursor(0, 1);
    lcd.print("RMS: ");
    lcd.print(nodeHistory[idx].features[2], 2);
    delay(700);
    lcd.clear();
    lcd.print("Re-sampling...");
    delay(500);
  }

  lcd.clear();
  lcd.print("Model Inference");
  lcd.setCursor(0, 1);
  lcd.print("Layers: 8-4-8");
  delay(500);

  // Run actual inference
  float reconError = runInference(nodeId);

  lcd.clear();
  lcd.print("Recon. Error:");
  lcd.setCursor(0, 1);
  lcd.print(reconError, 4);
  delay(600);

  if(random(0, 100) < 15) {
    lcd.clear();
    lcd.print("Warn: High loss");
    lcd.setCursor(0, 1);
    lcd.print("Recalculating...");
    delay(600);
    reconError = runInference(nodeId);
  }

  lcd.clear();
  lcd.print("XAI: Analyzing");
  lcd.setCursor(0, 1);
  lcd.print("Features: ");
  lcd.print(INPUT_DIM);
  delay(500);

  float confidence = (reconError > RECONSTRUCTION_THRESHOLD) ? 94.0 : 88.0;
  lcd.clear();
  lcd.print("Complete!");
  lcd.setCursor(0, 1);
  lcd.print("Conf: ");
  lcd.print(confidence, 0);
  lcd.print("%");
  delay(600);
}

void onDataReceive(const uint8_t *mac, const uint8_t *data, int len) {
  memcpy(&incomingData, data, sizeof(incomingData));

  int nodeId = incomingData.nodeId;
  int idx = nodeId - 1;
  float vibLevel = incomingData.vibrationLevel;

  // Update history
  nodeHistory[idx].lastUpdate = millis();

  // Extract features from incoming data
  extractFFTFeatures(nodeId, vibLevel);

  // Run inference on every data point
  float reconError = runInference(nodeId);

  // Determine if anomalous based on reconstruction error OR manual trigger
  bool mlDetected = (reconError > RECONSTRUCTION_THRESHOLD);
  bool isAnom = mlDetected || incomingData.isAnomalous || manualTrigger[nodeId - 1];

  Serial.print("[ESP-NOW] Node ");
  Serial.print(nodeId);
  Serial.print(" | Vib: ");
  Serial.print(vibLevel);
  Serial.print(" | ReconErr: ");
  Serial.print(reconError, 4);
  Serial.print(" | Status: ");
  Serial.println(isAnom ? "ANOMALY" : "NORMAL");

  // Show detailed ML process only when manually triggered (for demo)
  if(manualTrigger[nodeId - 1]) {
    displayMLProcess(nodeId, vibLevel);
    manualTrigger[nodeId - 1] = false; // Reset trigger after showing
  }

  lcd.clear();

  if(isAnom) {
    lcd.setCursor(0, 0);
    lcd.print("ALERT: Motor ");
    lcd.print(nodeId);

    lcd.setCursor(0, 1);
    String explanation = getXAIExplanation(nodeId, vibLevel);
    lcd.print(explanation);
  } else {
    lcd.setCursor(0, 0);
    lcd.print("M");
    lcd.print(nodeId);
    lcd.print(":OK Vib:");
    lcd.print(vibLevel, 1);

    lcd.setCursor(0, 1);
    lcd.print("Err:");
    lcd.print(reconError, 3);
    lcd.print(" Act");
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  // Initialize ML model
  randomSeed(analogRead(0));
  initializeModel();

  // Initialize sensor histories
  for(int i = 0; i < 3; i++) {
    nodeHistory[i].bufferIndex = 0;
    nodeHistory[i].reconstructionError = 0;
    nodeHistory[i].lastUpdate = 0;
    for(int j = 0; j < FFT_SIZE; j++) {
      nodeHistory[i].vibrationBuffer[j] = 0;
    }
  }

  Wire.begin(21, 22);
  lcd.init();
  lcd.backlight();

  lcd.clear();
  lcd.print("Initializing...");
  lcd.setCursor(0, 1);
  lcd.print("Loading model");
  delay(1000);

  WiFi.mode(WIFI_AP_STA);
  WiFi.softAP(ssid, password);

  Serial.println("\n=== Edge AI Gateway ===");
  Serial.print("AP IP: ");
  Serial.println(WiFi.softAPIP());
  Serial.print("MAC: ");
  Serial.println(WiFi.macAddress());

  if(esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW init failed");
    lcd.clear();
    lcd.print("ESP-NOW FAIL");
    while(1);
  }

  Serial.println("ESP-NOW initialized");

  esp_now_register_recv_cb(onDataReceive);

  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", html);
  });

  server.on("/trigger", HTTP_GET, [](AsyncWebServerRequest *request){
    if(request->hasParam("node")) {
      int node = request->getParam("node")->value().toInt();
      if(node >= 1 && node <= 2) {
        manualTrigger[node - 1] = true;
        Serial.println("[WEB] Manual trigger: Node " + String(node));
        // The ML process will be shown when next data arrives from sensor
      }
    }
    request->send(200, "text/plain", "OK");
  });

  server.on("/reset", HTTP_GET, [](AsyncWebServerRequest *request){
    manualTrigger[0] = false;
    manualTrigger[1] = false;
    Serial.println("[WEB] System reset");
    lcd.clear();
    lcd.print("System Reset");
    delay(1000);
    lcd.clear();
    lcd.print("Gateway Ready");
    request->send(200, "text/plain", "OK");
  });

  server.begin();

  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Gateway Ready");
  lcd.setCursor(0, 1);
  lcd.print(WiFi.softAPIP());

  Serial.println("Web server: http://192.168.4.1");
  Serial.println("WiFi: Gateway_Demo | Pass: 12345678");
  Serial.println("Listening for sensor nodes...");
}

void loop() {
}
